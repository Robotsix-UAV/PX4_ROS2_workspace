{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PX4_ROS2_workspace Documentation Overview Welcome to the PX4_ROS2_workspace documentation. This repository integrates the PX4 autopilot software with ROS 2, providing tools and scripts to facilitate development. This documentation will guide you through the installation, configuration, and usage of the PX4_ROS2_workspace. It is designed to help developers and users effectively utilize the tools and scripts provided in this repository. Dependencies This workspace requires only git and docker to be installed on your system. Docker containers provide all the necessary dependencies and tools to work with PX4 and ROS 2. Additionally, for SITL simulation using an NVIDIA GPU, you will need to have nvidia-container-runtime installed (available as a package under Ubuntu). Other GPUs are not supported.","title":"Home"},{"location":"#px4_ros2_workspace-documentation","text":"","title":"PX4_ROS2_workspace Documentation"},{"location":"#overview","text":"Welcome to the PX4_ROS2_workspace documentation. This repository integrates the PX4 autopilot software with ROS 2, providing tools and scripts to facilitate development. This documentation will guide you through the installation, configuration, and usage of the PX4_ROS2_workspace. It is designed to help developers and users effectively utilize the tools and scripts provided in this repository.","title":"Overview"},{"location":"#dependencies","text":"This workspace requires only git and docker to be installed on your system. Docker containers provide all the necessary dependencies and tools to work with PX4 and ROS 2. Additionally, for SITL simulation using an NVIDIA GPU, you will need to have nvidia-container-runtime installed (available as a package under Ubuntu). Other GPUs are not supported.","title":"Dependencies"},{"location":"collect_log/","text":"Drone Log Collection Script This script is designed to collect log files from multiple drones specified as a comma-separated list. It connects to each drone via SSH, retrieves the UAV name, creates a local directory, and synchronizes the logs from the remote drone to the local directory. Prerequisites Before using this script, ensure that: You have SSH access to all the drones. You have generated SSH keys for passwordless authentication. You must have run the install_offboard.sh script on each drone to set up the environment variables and log directories. Generate SSH Key (if not done already) ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" Copy the SSH Key to Each Drone To enable passwordless SSH connections to each drone, use the following command: ssh-copy-id user@ip_address Replace user@ip_address with the appropriate username and IP address for each drone. Usage Collecting Logs from a Single Drone To collect logs from a single drone, use the following command: ./collect_logs.sh user1@192.168.1.101 Replace user1@192.168.1.101 with the appropriate user@ip format for your drone. Collecting Logs from Multiple Drones To collect logs from multiple drones, you can specify a comma-separated list of drones in the format user@ip : ./collect_logs.sh user1@192.168.1.101,user2@192.168.1.102 Using an Environment Variable for Drone List Optionally, you can define the drone list as an environment variable, which can be added to your .bashrc for convenience. Export the drone list: bash export DRONES=\"user1@192.168.1.101,user2@192.168.1.102,user3@192.168.1.103\" Run the script using the environment variable: bash ./collect_logs.sh $DRONES To make the environment variable persistent, you can add the export DRONES line to your .bashrc file. Examples Single Drone: bash ./collect_logs.sh user1@192.168.1.101 Multiple Drones: bash ./collect_logs.sh user1@192.168.1.101,user2@192.168.1.102 Using Environment Variable: bash export DRONES=\"user1@192.168.1.101,user2@192.168.1.102,user3@192.168.1.103\" ./collect_logs.sh $DRONES Script Description The collect_logs.sh script performs the following steps: SSH Connection : Connects to each drone via SSH using the provided user@ip details. UAV Name Retrieval : Retrieves the UAV_NAME environment variable from the drone. Local Directory Creation : Creates a local directory based on the retrieved UAV_NAME to store the logs. Log Synchronization : Uses rsync to copy the logs from the drone to the local directory.","title":"Collecting offboard logs"},{"location":"collect_log/#drone-log-collection-script","text":"This script is designed to collect log files from multiple drones specified as a comma-separated list. It connects to each drone via SSH, retrieves the UAV name, creates a local directory, and synchronizes the logs from the remote drone to the local directory.","title":"Drone Log Collection Script"},{"location":"collect_log/#prerequisites","text":"Before using this script, ensure that: You have SSH access to all the drones. You have generated SSH keys for passwordless authentication. You must have run the install_offboard.sh script on each drone to set up the environment variables and log directories.","title":"Prerequisites"},{"location":"collect_log/#generate-ssh-key-if-not-done-already","text":"ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"","title":"Generate SSH Key (if not done already)"},{"location":"collect_log/#copy-the-ssh-key-to-each-drone","text":"To enable passwordless SSH connections to each drone, use the following command: ssh-copy-id user@ip_address Replace user@ip_address with the appropriate username and IP address for each drone.","title":"Copy the SSH Key to Each Drone"},{"location":"collect_log/#usage","text":"","title":"Usage"},{"location":"collect_log/#collecting-logs-from-a-single-drone","text":"To collect logs from a single drone, use the following command: ./collect_logs.sh user1@192.168.1.101 Replace user1@192.168.1.101 with the appropriate user@ip format for your drone.","title":"Collecting Logs from a Single Drone"},{"location":"collect_log/#collecting-logs-from-multiple-drones","text":"To collect logs from multiple drones, you can specify a comma-separated list of drones in the format user@ip : ./collect_logs.sh user1@192.168.1.101,user2@192.168.1.102","title":"Collecting Logs from Multiple Drones"},{"location":"collect_log/#using-an-environment-variable-for-drone-list","text":"Optionally, you can define the drone list as an environment variable, which can be added to your .bashrc for convenience. Export the drone list: bash export DRONES=\"user1@192.168.1.101,user2@192.168.1.102,user3@192.168.1.103\" Run the script using the environment variable: bash ./collect_logs.sh $DRONES To make the environment variable persistent, you can add the export DRONES line to your .bashrc file.","title":"Using an Environment Variable for Drone List"},{"location":"collect_log/#examples","text":"Single Drone: bash ./collect_logs.sh user1@192.168.1.101 Multiple Drones: bash ./collect_logs.sh user1@192.168.1.101,user2@192.168.1.102 Using Environment Variable: bash export DRONES=\"user1@192.168.1.101,user2@192.168.1.102,user3@192.168.1.103\" ./collect_logs.sh $DRONES","title":"Examples"},{"location":"collect_log/#script-description","text":"The collect_logs.sh script performs the following steps: SSH Connection : Connects to each drone via SSH using the provided user@ip details. UAV Name Retrieval : Retrieves the UAV_NAME environment variable from the drone. Local Directory Creation : Creates a local directory based on the retrieved UAV_NAME to store the logs. Log Synchronization : Uses rsync to copy the logs from the drone to the local directory.","title":"Script Description"},{"location":"firmware/","text":"Firmware Utilities Guide Introduction This guide provides instructions on how to use the firmware scripts to flash PX4 firmware to a device and upload parameters using Docker. Firmware Flashing The firmware_upload.sh script automates the process of setting up the PX4-Autopilot environment, checking out the desired git branch or tag, and flashing the firmware to a specified platform. If no options are provided, the script will ask for the necessary information through prompts. Usage Your device must be connected to your computer via USB. The script will automatically detect the device and flash the firmware. /tools/docker_scripts/firmware_upload.sh Options -h : Show help message and exit -b : Specify the git branch. -t : Specify the git tag (latest or custom). -p : Specify the target platform (e.g., px4_fmu-v6x). -a : Automatically clone PX4-Autopilot if not found. Examples /tools/docker_scripts/firmware_upload.sh -b main -p px4_fmu-v6x -a /tools/docker_scripts/firmware_upload.sh -t latest -p px4_fmu-v6x -a Parameters Upload The parameters_upload.sh script uploads parameters to a PX4 device using Docker. Usage Your device must be connected to your computer via USB. The script will automatically detect the device and upload the parameters. /tools/docker_scripts/parameters_upload.sh -f <path_to_parameter_file> Parameter File Structure The parameter file is a text file containing the parameters to upload. Each line should contain a parameter name and value separated by a space. Float parameters should be written with a decimal point as the type is inferred from the value. For example: UXRCE_DDS_CFG 1000 EKF2_ABIAS_INIT 0.15 See the PX4 documentation for a list of parameters. Options -h : Show help message and exit -f : Specify the parameter file defining the parameters to upload.","title":"Firmware"},{"location":"firmware/#firmware-utilities-guide","text":"","title":"Firmware Utilities Guide"},{"location":"firmware/#introduction","text":"This guide provides instructions on how to use the firmware scripts to flash PX4 firmware to a device and upload parameters using Docker.","title":"Introduction"},{"location":"firmware/#firmware-flashing","text":"The firmware_upload.sh script automates the process of setting up the PX4-Autopilot environment, checking out the desired git branch or tag, and flashing the firmware to a specified platform. If no options are provided, the script will ask for the necessary information through prompts.","title":"Firmware Flashing"},{"location":"firmware/#usage","text":"Your device must be connected to your computer via USB. The script will automatically detect the device and flash the firmware. /tools/docker_scripts/firmware_upload.sh","title":"Usage"},{"location":"firmware/#options","text":"-h : Show help message and exit -b : Specify the git branch. -t : Specify the git tag (latest or custom). -p : Specify the target platform (e.g., px4_fmu-v6x). -a : Automatically clone PX4-Autopilot if not found.","title":"Options"},{"location":"firmware/#examples","text":"/tools/docker_scripts/firmware_upload.sh -b main -p px4_fmu-v6x -a /tools/docker_scripts/firmware_upload.sh -t latest -p px4_fmu-v6x -a","title":"Examples"},{"location":"firmware/#parameters-upload","text":"The parameters_upload.sh script uploads parameters to a PX4 device using Docker.","title":"Parameters Upload"},{"location":"firmware/#usage_1","text":"Your device must be connected to your computer via USB. The script will automatically detect the device and upload the parameters. /tools/docker_scripts/parameters_upload.sh -f <path_to_parameter_file>","title":"Usage"},{"location":"firmware/#parameter-file-structure","text":"The parameter file is a text file containing the parameters to upload. Each line should contain a parameter name and value separated by a space. Float parameters should be written with a decimal point as the type is inferred from the value. For example: UXRCE_DDS_CFG 1000 EKF2_ABIAS_INIT 0.15 See the PX4 documentation for a list of parameters.","title":"Parameter File Structure"},{"location":"firmware/#options_1","text":"-h : Show help message and exit -f : Specify the parameter file defining the parameters to upload.","title":"Options"},{"location":"holybro_pixhawk_jetson_baseboard_setup/","text":"Holybro Pixhawk Jetson Baseboard setup Recovery Mode Setup Locate the DIP switch on the baseboard for entering recovery mode. Connect USB Connect USB to flash the Jetson Board. Install Jetson OS Install the OS following the guide at NVIDIA's Installation Guide (skip SDK Components). Power the Jetson through the 12V power and the Autopilot through the USB-C port near the ethernet port. Warning: the Jetson and the Pixhawk Autopilot have each their own power supply. Both should be connected to have the system working properly. Set up the Ethernet connection directly on the Jetson. Keyboard, mouse, and monitor are required for this step. Run the Install Offboard Script for ROS2_UAV_PX4 Install Docker using the steps at Docker Installation . To use Docker as a non-root user, follow the steps at Post-installation steps for Linux . Install cmake sudo apt-get install cmake Download and run the installation script: wget https://raw.githubusercontent.com/Robotsix-UAV/PX4_ROS2_workspace/main/tools/scripts/install_offboard.sh chmod +x install_offboard.sh sudo ./install_offboard.sh *uav_name* Replace uav_name with your specific UAV's name. Configure the microDDS Client on the PX4 Autopilot Set the parameter 'UXR_DDS_CFG' to 'Disabled' to avoid automatic start of the microDDS client (does not support namespaces). Set the microDDS client via the mavlink shell: mkdir /fs/microsd/etc echo \"uxrce_dds_client start -t udp -p 8888 -h *Jetson IP* -n *uav_name*\" >> /fs/microsd/etc/extras.txt Replace uav_name and Jetson IP with your specific UAV's name and the Jetson's IP address. Do not forget to compile the PX4 firmware with the appropriate microDDS configuration. If you use the firmware flashing utility from the PX4_ROS2_workspace, the firmware will be compiled with the correct configuration. Usage The installation script generate convenient aliases to start the nodes. They are in the ~/.bashrc file. After installation you need to source the ~/.bashrc file to use the aliases (or restart the terminal). All launch files from ros2_uav_px4 get aliases through the installation script. To start the offboard modes: launch_offboard_modes The script execute the launch file on the docker container 'ros2_uav_offboard'. Proper execution of the nodes can be checked by running: docker attach ros2_uav_offboard","title":"Holybro Pixhawk Jetson Baseboard Setup"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#holybro-pixhawk-jetson-baseboard-setup","text":"","title":"Holybro Pixhawk Jetson Baseboard setup"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#recovery-mode-setup","text":"Locate the DIP switch on the baseboard for entering recovery mode.","title":"Recovery Mode Setup"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#connect-usb","text":"Connect USB to flash the Jetson Board.","title":"Connect USB"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#install-jetson-os","text":"Install the OS following the guide at NVIDIA's Installation Guide (skip SDK Components). Power the Jetson through the 12V power and the Autopilot through the USB-C port near the ethernet port. Warning: the Jetson and the Pixhawk Autopilot have each their own power supply. Both should be connected to have the system working properly. Set up the Ethernet connection directly on the Jetson. Keyboard, mouse, and monitor are required for this step.","title":"Install Jetson OS"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#run-the-install-offboard-script-for-ros2_uav_px4","text":"Install Docker using the steps at Docker Installation . To use Docker as a non-root user, follow the steps at Post-installation steps for Linux . Install cmake sudo apt-get install cmake Download and run the installation script: wget https://raw.githubusercontent.com/Robotsix-UAV/PX4_ROS2_workspace/main/tools/scripts/install_offboard.sh chmod +x install_offboard.sh sudo ./install_offboard.sh *uav_name* Replace uav_name with your specific UAV's name.","title":"Run the Install Offboard Script for ROS2_UAV_PX4"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#configure-the-microdds-client-on-the-px4-autopilot","text":"Set the parameter 'UXR_DDS_CFG' to 'Disabled' to avoid automatic start of the microDDS client (does not support namespaces). Set the microDDS client via the mavlink shell: mkdir /fs/microsd/etc echo \"uxrce_dds_client start -t udp -p 8888 -h *Jetson IP* -n *uav_name*\" >> /fs/microsd/etc/extras.txt Replace uav_name and Jetson IP with your specific UAV's name and the Jetson's IP address. Do not forget to compile the PX4 firmware with the appropriate microDDS configuration. If you use the firmware flashing utility from the PX4_ROS2_workspace, the firmware will be compiled with the correct configuration.","title":"Configure the microDDS Client on the PX4 Autopilot"},{"location":"holybro_pixhawk_jetson_baseboard_setup/#usage","text":"The installation script generate convenient aliases to start the nodes. They are in the ~/.bashrc file. After installation you need to source the ~/.bashrc file to use the aliases (or restart the terminal). All launch files from ros2_uav_px4 get aliases through the installation script. To start the offboard modes: launch_offboard_modes The script execute the launch file on the docker container 'ros2_uav_offboard'. Proper execution of the nodes can be checked by running: docker attach ros2_uav_offboard","title":"Usage"},{"location":"quick_start/","text":"Quick Start Guide: Launching a Simulation with ROS2_UAV Framework Prerequisites Install Docker and ensure it is running on your system. You will need the nvidia-container-runtime since the simulation requires NVIDIA GPUs. Download the latest QGroundControl to access the necessary modes. Steps 1. Launch the PX4 SITL Simulation Go to the tools/docker_scripts folder and start the simulation using the provided custom configuration file: cd tools/docker_scripts ./launch_simulation.sh -f ../configurations/simulation_config_custom.yaml -b main -a This command opens a Gazebo window featuring drone models, with the px4_sitl container running in the background. 2. Launch the Control Nodes Return to the tools/docker_scripts folder and initiate the control nodes using the same configuration file: cd tools/docker_scripts ./launch_simulation_nodes.sh -f ../configurations/simulation_config_custom.yaml This action starts the ros2_uav_px4 container, controlling the drones in the background. 3. Retrieve Docker IP Address Get the IP address of your Docker container running the PX4 SITL: docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' px4_sitl 4. Configure Communication Links in QGroundControl Adding a New Link Open QGroundControl. Proceed to Application Settings . Click Comm Links in the sidebar. Hit Add . Select UDP as the Type. Specify the Port as 18570 + drone_number . For instance, for drone number 1 (namespace /uav1), set it to 18571 . Input the Docker IP you noted earlier into Server Addresses . Press Add Server . Click Save . Connect the Link After setup, choose the newly added link and click Connect to link up with the drone. 5. Selecting the Mode From the main screen of QGroundControl, pick a mode for your drone, such as Offboard Position . The drone will ascend and hover at a designated altitude, with position control managed by the ros2_uav_px4 container's control node. 6. Sending a Setpoint cd tools/docker_scripts ./send_setpoint.sh uav0 0 0 2 0 Here, uav0 is the drone's namespace, 0 0 2 represents the x, y, z coordinates, and 0 is the heading.","title":"Quick Start"},{"location":"quick_start/#quick-start-guide-launching-a-simulation-with-ros2_uav-framework","text":"","title":"Quick Start Guide: Launching a Simulation with ROS2_UAV Framework"},{"location":"quick_start/#prerequisites","text":"Install Docker and ensure it is running on your system. You will need the nvidia-container-runtime since the simulation requires NVIDIA GPUs. Download the latest QGroundControl to access the necessary modes.","title":"Prerequisites"},{"location":"quick_start/#steps","text":"","title":"Steps"},{"location":"quick_start/#1-launch-the-px4-sitl-simulation","text":"Go to the tools/docker_scripts folder and start the simulation using the provided custom configuration file: cd tools/docker_scripts ./launch_simulation.sh -f ../configurations/simulation_config_custom.yaml -b main -a This command opens a Gazebo window featuring drone models, with the px4_sitl container running in the background.","title":"1. Launch the PX4 SITL Simulation"},{"location":"quick_start/#2-launch-the-control-nodes","text":"Return to the tools/docker_scripts folder and initiate the control nodes using the same configuration file: cd tools/docker_scripts ./launch_simulation_nodes.sh -f ../configurations/simulation_config_custom.yaml This action starts the ros2_uav_px4 container, controlling the drones in the background.","title":"2. Launch the Control Nodes"},{"location":"quick_start/#3-retrieve-docker-ip-address","text":"Get the IP address of your Docker container running the PX4 SITL: docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' px4_sitl","title":"3. Retrieve Docker IP Address"},{"location":"quick_start/#4-configure-communication-links-in-qgroundcontrol","text":"","title":"4. Configure Communication Links in QGroundControl"},{"location":"quick_start/#adding-a-new-link","text":"Open QGroundControl. Proceed to Application Settings . Click Comm Links in the sidebar. Hit Add . Select UDP as the Type. Specify the Port as 18570 + drone_number . For instance, for drone number 1 (namespace /uav1), set it to 18571 . Input the Docker IP you noted earlier into Server Addresses . Press Add Server . Click Save .","title":"Adding a New Link"},{"location":"quick_start/#connect-the-link","text":"After setup, choose the newly added link and click Connect to link up with the drone.","title":"Connect the Link"},{"location":"quick_start/#5-selecting-the-mode","text":"From the main screen of QGroundControl, pick a mode for your drone, such as Offboard Position . The drone will ascend and hover at a designated altitude, with position control managed by the ros2_uav_px4 container's control node.","title":"5. Selecting the Mode"},{"location":"quick_start/#6-sending-a-setpoint","text":"cd tools/docker_scripts ./send_setpoint.sh uav0 0 0 2 0 Here, uav0 is the drone's namespace, 0 0 2 represents the x, y, z coordinates, and 0 is the heading.","title":"6. Sending a Setpoint"},{"location":"simulation/","text":"Simulation Guide Introduction This guide provides instructions on how to use the simulation scripts to generate airframe models and launch simulations for PX4 Autopilot with Gazebo using Docker. Generate Airframe Model Description The PX4 repository contains models for various airframes. However, you may need to create a custom airframe model for your vehicle. The generate_airframe.sh script generates a model for a multirotor vehicle based on configurations provided in a YAML file. It will generate a .sdf file for the airframe model, which can be used in Gazebo simulations already containing the plugins required for PX4 SITL simulation. It will also generate a configuration file for the airframe model, which can be used to specify the vehicle parameters in the PX4 firmware. The generated airframe model will be saved in the gz_sim/custom_airframes directory. The model visuals are very basic, but you can modify the generated .sdf file to provide your own meshes afterward. Usage /tools/docker_scripts/generate_airframe.sh -f <path_to_yaml_file> YAML Configuration Structure model_name: \"model_name\" arm_length: 1.0 # in meters num_motors: 4 # Should be at least 2 and even angle_offset: 45 # in degrees weight: 1.0 # in kg Ixx: 0.03 # in kg*m^2 Iyy: 0.03 # in kg*m^2 Izz: 0.03 # in kg*m^2 max_motor_thrust: 10.0 # in N first_motor_cw: true # Optional, defaults to True angle_offset is the angle between the first motor and the x-axis to use when no motor is aligned with the x-axis of the UAV. first_motor_cw specifies if the first motor rotates clockwise. If not specified, it defaults to True . The motors will be alternatively clockwise and counterclockwise. Options -h : Show help message and exit -f : Specify the configuration file to use Simulation with Gazebo The launch_simulation.sh script automates the launch of a simulation for PX4 Autopilot with Gazebo using Docker. Usage /tools/docker_scripts/launch_simulation.sh -f <path_to_yaml_file> YAML Configuration Structure headless: false world: default models: - name: gz_x500 pose: [0, 0, 0, 0, 0, 0] - name: gz_x500 pose: [2, 0, 0, 0, 0, 0] headless specifies whether to run the simulation in headless mode. If not specified, it defaults to False . world specifies the world file to use for the simulation. Any world of the PX4 repository or any custom world in the gz_sim/custom_worlds directory can be used. models is a list of models to spawn in the simulation. Each model has a name and a pose in the format [x, y, z, roll, pitch, yaw] . Any model of the PX4 repository or any custom model in the gz_sim/custom_airframes directory can be used. Options -h : Show help message and exit -b : Specify the git branch of the PX4-Autopilot repository. -t : Specify the git tag (latest or custom) of the PX4-Autopilot repository. -f : Specify the configuration file for the simulation. -a : Automatically clone PX4-Autopilot repository if not found. Both -b and -t options cannot be used at the same time. If neither is provided, the script will use the current branch of the PX4-Autopilot repository.","title":"Simulation"},{"location":"simulation/#simulation-guide","text":"","title":"Simulation Guide"},{"location":"simulation/#introduction","text":"This guide provides instructions on how to use the simulation scripts to generate airframe models and launch simulations for PX4 Autopilot with Gazebo using Docker.","title":"Introduction"},{"location":"simulation/#generate-airframe-model","text":"","title":"Generate Airframe Model"},{"location":"simulation/#description","text":"The PX4 repository contains models for various airframes. However, you may need to create a custom airframe model for your vehicle. The generate_airframe.sh script generates a model for a multirotor vehicle based on configurations provided in a YAML file. It will generate a .sdf file for the airframe model, which can be used in Gazebo simulations already containing the plugins required for PX4 SITL simulation. It will also generate a configuration file for the airframe model, which can be used to specify the vehicle parameters in the PX4 firmware. The generated airframe model will be saved in the gz_sim/custom_airframes directory. The model visuals are very basic, but you can modify the generated .sdf file to provide your own meshes afterward.","title":"Description"},{"location":"simulation/#usage","text":"/tools/docker_scripts/generate_airframe.sh -f <path_to_yaml_file>","title":"Usage"},{"location":"simulation/#yaml-configuration-structure","text":"model_name: \"model_name\" arm_length: 1.0 # in meters num_motors: 4 # Should be at least 2 and even angle_offset: 45 # in degrees weight: 1.0 # in kg Ixx: 0.03 # in kg*m^2 Iyy: 0.03 # in kg*m^2 Izz: 0.03 # in kg*m^2 max_motor_thrust: 10.0 # in N first_motor_cw: true # Optional, defaults to True angle_offset is the angle between the first motor and the x-axis to use when no motor is aligned with the x-axis of the UAV. first_motor_cw specifies if the first motor rotates clockwise. If not specified, it defaults to True . The motors will be alternatively clockwise and counterclockwise.","title":"YAML Configuration Structure"},{"location":"simulation/#options","text":"-h : Show help message and exit -f : Specify the configuration file to use","title":"Options"},{"location":"simulation/#simulation-with-gazebo","text":"The launch_simulation.sh script automates the launch of a simulation for PX4 Autopilot with Gazebo using Docker.","title":"Simulation with Gazebo"},{"location":"simulation/#usage_1","text":"/tools/docker_scripts/launch_simulation.sh -f <path_to_yaml_file>","title":"Usage"},{"location":"simulation/#yaml-configuration-structure_1","text":"headless: false world: default models: - name: gz_x500 pose: [0, 0, 0, 0, 0, 0] - name: gz_x500 pose: [2, 0, 0, 0, 0, 0] headless specifies whether to run the simulation in headless mode. If not specified, it defaults to False . world specifies the world file to use for the simulation. Any world of the PX4 repository or any custom world in the gz_sim/custom_worlds directory can be used. models is a list of models to spawn in the simulation. Each model has a name and a pose in the format [x, y, z, roll, pitch, yaw] . Any model of the PX4 repository or any custom model in the gz_sim/custom_airframes directory can be used.","title":"YAML Configuration Structure"},{"location":"simulation/#options_1","text":"-h : Show help message and exit -b : Specify the git branch of the PX4-Autopilot repository. -t : Specify the git tag (latest or custom) of the PX4-Autopilot repository. -f : Specify the configuration file for the simulation. -a : Automatically clone PX4-Autopilot repository if not found. Both -b and -t options cannot be used at the same time. If neither is provided, the script will use the current branch of the PX4-Autopilot repository.","title":"Options"},{"location":"structure/","text":"Repository Structure The repository contains the following key directories and files: docker/ - Directory containing Dockerfiles for building Docker images used in the project. docs/ - Directory containing documentation files. gz_sim/ - Directory containing Gazebo custom simulation files. custom_airframes/ - Directory containing custom airframe models for the Gazebo simulator with PX4 SITL. custom_worlds/ - Directory containing custom world models for the Gazebo simulator with PX4 SITL. log/ - Directory to collect log files from the drones. tests/ - Directory containing test scripts. tools/ - Directory containing various utility scripts. configurations/ - Directory containing examples of configuration files for the scripts. docker_scripts/ - Directory containing scripts that run Docker containers. scripts/ - Directory containing shell and Python scripts called by the Docker scripts. These can be run outside of Docker as well with proper dependencies installed.","title":"Repository Structure"},{"location":"structure/#repository-structure","text":"The repository contains the following key directories and files: docker/ - Directory containing Dockerfiles for building Docker images used in the project. docs/ - Directory containing documentation files. gz_sim/ - Directory containing Gazebo custom simulation files. custom_airframes/ - Directory containing custom airframe models for the Gazebo simulator with PX4 SITL. custom_worlds/ - Directory containing custom world models for the Gazebo simulator with PX4 SITL. log/ - Directory to collect log files from the drones. tests/ - Directory containing test scripts. tools/ - Directory containing various utility scripts. configurations/ - Directory containing examples of configuration files for the scripts. docker_scripts/ - Directory containing scripts that run Docker containers. scripts/ - Directory containing shell and Python scripts called by the Docker scripts. These can be run outside of Docker as well with proper dependencies installed.","title":"Repository Structure"}]}